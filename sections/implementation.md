Implementation
==============

\label{chap:impl}

\todo{Write an opening paragraph for this section, introducing the Wire type.}

Most of the operations of the Wire type are the operations of the basic arrow
typeclasses. Wire is also an arrow transformer and an instance of the
`ArrowCircuit` typeclass\citep{automatonArrows}.

Beyond its typeclasses, given in Figure\ \ref{fig:wireTypeclasses}, `Wire` also
admits two other operations: `stepWire` and `accumulate`.

\begin{figure}[h]

\begin{itemize}
 \item `Category` if the underlying arrow has an `Arrow` instance
 \item `Arrow` if the underlying arrow has an `Arrow` instance
 \item `ArrowChoice` if the underlying arrow has an `ArrowChoice` instance
 \item `ArrowZero` if the underlying arrow has an `ArrowZero` instance
 \item `ArrowPlus` if the underlying arrow has an `ArrowPlus` instance
 \item `ArrowTransformer` if the underlying arrow has an `Arrow` instance
\end{itemize}

\caption{The typeclasses of the \texttt{Wire} type.}
\label{fig:wireTypeclasses}
\end{figure}

\input{annsrc/Wire.tex}

Proofs
------

There are laws associated with arrows, which it would be convenient
to prove. Rather than proving them by hand, which would be immeasurably
tedious, I opted to use a proof assistant.

The major category of proof assistants use dependent
types\cite{depProofAssistant}. Dependent types are a type system which can
contain values as part of the type\cite{depTypes}. They are useful for enforcing
certain properties at the type level.

The classic example of the power of dependent types is being able to type
fixed-length vectors. Consider lists. One can imagine `List` as a function at
the type level, taking an element type and producing the type of lists of
elements of that type. The type of the map function for lists is $(a \to b) \to
\texttt{List}\: a \to \texttt{List}\: b$. A number of the interesting properties
of this type arise from its free theorem\cite{freeTheorems} - but not the
complete `Functor` properties. There is an issue that for any $a$ and $b$, the
type is inhabited by $const\: []$.

In a dependent type system, one need not imagine `List` as being
an endofunction on types, since `List` actually *is* an endofunction
on types. A type more illustrative of the power of dependent types,
however, is generated by `Vect` which has the type $\texttt{Type}
\to \mathbb{N} \to \texttt{Type}$ -- the type of fixed-length
vectors. Mapping over fixed-length vectors would be of type $(a \to
b) \to \texttt{Vect}\: n\: a \to \texttt{Vect}\: n\: b$[^dtdesug].

Crucially, this type is not inhabited by the irritating special-case
that exists for lists. Further than that, the type of the concatenation
function for fixed-length vectors is $\texttt{Vect}\: n\: a \to
\texttt{Vect}\: m\: a \to \texttt{Vect}\: (n + m)\: a$ -- a type
which makes guarantees about the number of elements in the result.

The power of dependent types comes from the existence of *proof
types*. These are types of the form $a = b$, and are inhabited by
one value if $a$ and $b$ are identical, and uninhabited
otherwise\cite{depProofAssistant}.  Coupled with the interdependence
offered by dependent types, this can be powerful on its own for
programming[^isodep], and is used in a non-dependent context within
GHC for implementation of GADTs\cite{gadts}.

It is possible to use these proof types at the top-level, and
constructing a value of a particular proof type is sufficient to
prove the statement to which it corresponds.

Within the family of dependently-typed proof-assistants, I will
look at three options: Coq, Agda, and Idris.

[^dtdesug]: This is somewhat of a cheat, desugaring this yields $(a :
\texttt{Type}) \to (b : \texttt{Type}) \to (n : \mathbb{N}) \to (a \to b) \to
\texttt{Vect}\: n\: a \to \texttt{Vect}\: n\: b$. This makes it clear that parts
of the type *depend* on other parts of the type -- hence the name 'dependent
types'.

[^isodep]: In a dependent type system, isomorphisms can be practically written
as a 4-tuple: two function $f : a \to b$ and $g : b \to a$ coupled with two
proofs, $(x : a) \to g\: (f\: x) = x$ and $(x : b) \to f\: (g\: x) = x$. In the
standard library of Idris, this very form is used\cite{idrIso}.

### Coq

\todo{Expand me!}

Of the three proof assistants, Coq is by far the oldest: it was first
released in 1984\cite{coqRef}.

### Idris

\todo{Expand me too!}

Idris is a relatively new language, and unlike Coq and Agda is
designed as a general-purpose programming language with dependent
types, rather than as a proof-assistant from the start\cite{idris}.
It does, however, have proof-assistant capabilities\cite{idrisProof}.

### Agda

\todo{Particularly expand me!}

Agda is unusual in the domain of proof assistants as the usual style of
"list of tactics" is eschewed in favour of proofs written in a functional
programming style\cite{agda}.

### Decision

\todo{better title}

All three of these systems have merits. Whilst I tried all of them, I opted
-- in the end -- for Agda. Coq is the furthest removed from Haskell of the
three which meant more to learn and introduced more scope for errors in
translation; Idris's support for proofs is still in relatively early stages
and I found proofs in it rather tricky[^because]. Agda is outwardly similar
to Haskell in many ways (types can be written, for instance, using the very
familiar GADT syntax of Haskell) but is very dependable and eminently
stable.

I had some difficulty with one particular proof case in Agda, which
involved trying express that the cartesian-product of types is
associative. Having done so, I proved all the arrow and category
laws for `Wire`. The Agda proofs are in Appendix\ \ref{apx:proofs}.

[^because]: This may be because Idris is designed primarily as a
programming language rather than a proof-assistant.

Idempotent
----------

\label{sec:idempotent}

It is often wise to place constraints in order to guarantee that a
system behaves "sensibly", for some definition thereof. The type I
have given for wires could accept the full generality of state types
and functions[^bitoa]. However, it is possible to make tighter guarantees
about its behaviour.

[^bitoa]: It is isomorphic, as mentioned *ad nauseam*, to the
automaton arrow transformer, which does accept the full generality of
state types.

In particular, it would be nice to enforce a consistency property:
stepping a wire multiple times with unchanging inputs will not lead to
changing outputs. This allows us to reason about parts of an FRP
network which will not change under certain circumstances.

Accumulating values in a monoid is a simple operation, but general
enough to allow for a range of different and useful behaviours.
Using the `Last` monoid on `Maybe` types gives a latching behaviour;
using monoids from extrema allows one to track the limits of a value
that have been held at previous points. However, the addition monoid
(as an example) gives an integration behaviour which does not obey
the aforementioned consistency property of unchanging inputs leading
to unchanging outputs.

To enforce that property, we require that the accumulating monoids be
idempotent. There is no typeclass for idempotent monoids
anywhere within Haskell's standard libraries[^1].

[^1]: That is to say, libraries included with GHC or the Haskell platform.

As a result, I wrote the typeclass as well as its common instances and factored
them out to a separate library, which then was published on Haskell's package
index, Hackage\cite{hackage:idempotent} (see \ref{sub:hackage}).

Improving Arrows
----------------

\label{sec:improve}

Certain arrows are relatively heavyweight\todo{Rephrase}. This often
stretches to arrows which are created from the `arr` and `id`
functions both of which could be expected to be cheap, and certainly
one might imagine that they could be folded together.

Additionally, there are a number of typeclasses that all arrows
satisfy, but which it is tedious to enumerate for every arrow
implemented -- `Functor`, `Profunctor`\cite{hackage:profunctors},
`Strong` and `Applicative`\cite{applicatives} for all arrows as
well as `Alternative` (and `Monoid`, following the precedent set
by Paterson in the `arrows` package\cite{hackage:arrows}) for arrows
satisfying `ArrowPlus`, `Choice` for arrows satisfying `ArrowChoice`,
and others.

I introduced an arrow wrapper, `ImproveArrow`, which wraps any
existing arrow while providing cheap `arr` and `id` which are
necessarily fused, and providing the set of instances mentioned
above. As with the idempotent package, this was then published on
Hackage\cite{hackage:arrow-improve}. It is in some ways analogous
to the `CoYoneda`\cite{hackage:kan-extensions} type as it applies
to Functors, in that it folds mappings into single functions, albeit
mappings via composition and `arr` rather than `fmap`.

Practical Concerns
------------------

From a practical point of view, the development -- both of the main
implementation itself as well as the support libraries discussed above -- was
done using a number of tools.

### git

`git` is a distributed version control system\cite{ws:git}. It was written by Linus Torvalds to replace the BitKeeper source control system
for Linux\cite{gitTorvalds}, and is now used in a number of large projects and
by a number of large organisations\cite{ws:git}, including the University of
Southampton\cite{ws:sotonGit}.

I opted to use it as a matter of personal familiarity over other distributed
version control systems, although above centralised version control systems due
to a need to work in locations without access to the Internet.

### GitHub

\label{sub:github}

`GitHub` is a hosting service for `git` repositories\cite{ws:github}. As a large
company\cite{githubLargeBlog}\cite{githubLargeWSJ}, a certain degree of trust is
established for their not collapsing and losing data. For this reason, I opted
for them for hosting of the `git` repositories I used, although naturally I kept
mirrors within ECS.

### QuickCheck

QuickCheck is a property-based testing tool for Haskell\cite{quickcheck}. I used
it in the `idempotent` library to test the idempotence properties on each of the
instances, as well as the monoid properties of the `Min` and `Max` extrema
newtypes.

### Travis CI

Travis is a continous integration tool\cite{ws:travis}. It is tightly coupled to
GitHub\cite{ws:travisDocs}. I used it for automated builds and tests for all
parts of the project.

### Cabal

Cabal is a system for building and packaging Haskell libraries and
programs\cite{ws:cabal}. The various components I implemented each include the
necessary metadata[^meta] to be built and installed using Cabal.

[^meta]: The key files being `Setup.hs` and the main `.cabal` file which
contains the package metadata and build instructions\cite{ws:cabalUserGuide}.

### Haddock

\label{sub:haddock}

Haddock is a documentation generation system for Haskell\cite{haddock},
analogous to Doxygen\cite{ws:doxygen} or Javadoc\cite{ws:javadoc}. Both the
`idempotent` and `arrow-improve` packages have Haddock documentation for all
exported modules, declarations and values.

### Hackage

\label{sub:hackage}

Hackage is a Haskell-specific package database\cite{ws:hackage}. It is analogous
to `npm`\cite{ws:npm} or PyPI\cite{ws:pypi}.

